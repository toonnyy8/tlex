{"version":3,"sources":["nfa.ts","dfa.ts","driver.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"..\\src","sourcesContent":["import { typeNFA } from './type'\r\n\r\nexport const char = (elem: RegExp): typeNFA => [{ action: elem.source, offsets: [1] }, { action: null, offsets: <number[]>[] }]\r\nexport const chars = (...elems: RegExp[]): Array<typeNFA> => {\r\n    return elems\r\n        .map(elem => char(elem))\r\n}\r\n\r\nexport const and = (...vocs: Array<typeNFA>): typeNFA => {\r\n    if (vocs.length > 1) return [\r\n        ...vocs[0].slice(0, -1), { ...vocs[0].slice(-1)[0], offsets: [1] },\r\n        ...and(...vocs.slice(1))\r\n    ]\r\n    else return [...vocs[0]]\r\n}\r\n\r\nexport const or = (...vocs: Array<typeNFA>): typeNFA => {\r\n    if (vocs.length > 1) {\r\n        let _or = or(...vocs.slice(1))\r\n        return [\r\n            { action: null, offsets: [1, vocs[0].length + 1] },\r\n            ...vocs[0].slice(0, -1), { ...vocs[0].slice(-1)[0], offsets: [_or.length + 1] },\r\n            ..._or.slice(0, -1), { ..._or.slice(-1)[0], offsets: [1] },\r\n            { action: null, offsets: [] }\r\n        ]\r\n    } else return [...vocs[0].slice(0, -1), { ...vocs[0].slice(-1)[0], offsets: [] },]\r\n}\r\n\r\nexport const kleene = (voc: typeNFA): typeNFA => {\r\n    return [\r\n        { action: null, offsets: [1, voc.length + 1] },\r\n        ...voc.slice(0, -1), { ...voc.slice(-1)[0], offsets: [-voc.length + 1, 1] },\r\n        { action: null, offsets: [] }\r\n    ]\r\n}","import { typeNFA, typeDFA, typeInterClosureLink, typeInterClosure, typeClosure } from \"./type\"\r\n\r\nexport const InterClosure = (nfa: typeNFA, state = 0): typeInterClosure => {\r\n    const _InterClosure = (nfa: typeNFA, state = 0): typeInterClosure => {\r\n        if (nfa[state].action === null) {\r\n            return nfa[state]\r\n                .offsets\r\n                .map(offset => _InterClosure(nfa, state + offset))\r\n                .reduce((last, cl) =>\r\n                    ({\r\n                        elems: [...last.elems, ...cl.elems],\r\n                        links: [...last.links, ...cl.links]\r\n                    }),\r\n                    <typeInterClosure>{ elems: [state], links: [] }\r\n                )\r\n        } else {\r\n            return <typeInterClosure>{\r\n                elems: [state],\r\n                links: [{ action: nfa[state].action, toElems: [state + nfa[state].offsets[0]] }]\r\n            }\r\n        }\r\n    }\r\n    let icl = _InterClosure(nfa, state)\r\n    icl = {\r\n        elems: [...icl.elems]\r\n            .sort((a, b) => a - b),\r\n        links: mergeILinks(icl.links),\r\n    }\r\n\r\n    return icl\r\n}\r\nlet arrEq = <T>(as: Array<T>, bs: Array<T>, eq: (a: T, b: T) => boolean) => {\r\n    if (as.length !== bs.length) return false\r\n    return as.find((a, idx) => !eq(a, bs[idx])) === undefined\r\n}\r\nlet arrAdd = <T>(as: Array<T>, b: T, eq: (a: T, b: T) => boolean) => {\r\n    if (as.find((a) => eq(a, b)) === undefined) return [...as, b]\r\n    else return [...as]\r\n}\r\nlet arrMerge = <T>(as: Array<T>, bs: Array<T>, eq: (a: T, b: T) => boolean) => {\r\n    return bs.reduce((prevs, b) => arrAdd(prevs, b, eq), as)\r\n}\r\nconst mergeILinks = (ilinks: Array<typeInterClosureLink>) => {\r\n    return [...ilinks]\r\n        .sort((a, b) => a.action > b.action ? 1 : a.action === b.action ? 0 : -1)\r\n        .reduce((prevs, curr) => {\r\n            if (prevs.length != 0) {\r\n                let prev = prevs[prevs.length - 1]\r\n                if (prev.action === curr.action) return [\r\n                    ...prevs.slice(0, -1),\r\n                    { ...prev, toElems: arrMerge(prev.toElems, curr.toElems, (a, b) => a === b) }\r\n                ]\r\n                else return [...prevs, curr]\r\n            }\r\n            else return [curr]\r\n        }, <Array<typeInterClosureLink>>[])\r\n}\r\nconst mergeIclosures = (iclosures: typeInterClosure[]): typeInterClosure => {\r\n    return iclosures\r\n        .reduce((prev, curr) => {\r\n            return {\r\n                elems: arrMerge(prev.elems, curr.elems, (a, b) => a === b).sort((a, b) => a - b),\r\n                links: mergeILinks(\r\n                    arrMerge(\r\n                        prev.links,\r\n                        curr.links,\r\n                        (a, b) => a.action === b.action && arrEq(a.toElems, b.toElems, (a, b) => a === b),\r\n                    )\r\n                )\r\n            }\r\n        }, <typeInterClosure>{ elems: [], links: [] })\r\n}\r\nexport const unfold = (nfa: typeNFA): typeClosure[] => {\r\n    let solved: typeClosure[] = []\r\n    let unsolved: typeInterClosure[] = [InterClosure(nfa)]\r\n\r\n    while (unsolved.length !== 0) {\r\n        let { all, now } = unsolved[0]\r\n            .links\r\n            .reduce(({ all, now }, link) => {\r\n                let icls = link.toElems.map(toElem => InterClosure(nfa, toElem))\r\n                let icl = mergeIclosures(icls)\r\n                let idx = all.findIndex((_cl) => arrEq(icl.elems, _cl.elems, (a, b) => a === b))\r\n                if (idx === -1) {\r\n                    now = { ...now, links: [...now.links, { action: link.action, toClosure: all.length }] }\r\n                    return { all: [...all, icl], now }\r\n                }\r\n                else {\r\n                    now = { ...now, links: [...now.links, { action: link.action, toClosure: idx }] }\r\n                    return { all, now }\r\n                }\r\n            }, { all: [...solved, ...unsolved], now: <typeClosure>{ elems: unsolved[0].elems, links: [] } })\r\n        unsolved = <Array<typeInterClosure>>all.slice(solved.length + 1)\r\n        solved = [...solved, now]\r\n    }\r\n\r\n    return solved\r\n}\r\n\r\nexport const toDFA = (nfa: typeNFA): typeDFA => {\r\n    let cls = unfold(nfa)\r\n    return <typeDFA>cls.map(cl => {\r\n        if (cl.elems[cl.elems.length - 1] === nfa.length - 1) {\r\n            return { exit: true, links: cl.links.map(link => ({ action: link.action, next: link.toClosure })) }\r\n        } else {\r\n            return { exit: false, links: cl.links.map(link => ({ action: link.action, next: link.toClosure })) }\r\n        }\r\n    })\r\n}","import { typeNFA, typeRule, typeToken, typeTokenValue } from \"./type\"\r\nimport { toDFA } from \"./dfa\"\r\n\r\nexport const rule = (token: string, exp: typeNFA): typeRule => ({\r\n    token: token,\r\n    dfa: toDFA(exp),\r\n})\r\n\r\nexport const Driver = (...rules: typeRule[]): {\r\n    reset: () => void,\r\n    addCode: (code: string) => string,\r\n    genToken: () => 0 | 1 | -1,\r\n    getToken: () => typeToken,\r\n    dropToken: () => 0 | -1,\r\n} => {\r\n    let states: Array<number> = new Array(rules.length).fill(0)\r\n    let tokensValue: Array<typeTokenValue> = new Array(rules.length).fill({ value: \"\", temp: \"\" })\r\n\r\n    let _rules = rules\r\n        .map(rule => ({\r\n            ...rules,\r\n            dfa: rule\r\n                .dfa\r\n                .map(_dfa => ({\r\n                    ..._dfa,\r\n                    links: _dfa\r\n                        .links\r\n                        .map(link => ({\r\n                            ...link,\r\n                            action: new RegExp(link.action)\r\n                        }))\r\n                }))\r\n        }))\r\n    let source: string\r\n    let line: number = 0\r\n    let col: number = 0\r\n    let token: typeToken = null\r\n    // generated = -1 : semifinished\r\n    // generated = 0  : not generated\r\n    // generated = 1  : finished\r\n    let generated: -1 | 0 | 1\r\n\r\n    let reset = () => {\r\n        source = \"\"\r\n        line = 0\r\n        col = 0\r\n    }\r\n    let addCode = (code: string) => {\r\n        source += code\r\n        return source\r\n    }\r\n\r\n    let genToken = () => {\r\n        if (source[0] === \"\\n\") {\r\n            line += 1\r\n            col = 0\r\n        }\r\n        switch (generated) {\r\n            case -1: {\r\n                if (source.length !== 0) {\r\n                    states = _rules\r\n                        .map((rule, idx) => {\r\n                            if (states[idx] !== -1) {\r\n                                tokensValue[idx] = {\r\n                                    value: tokensValue[idx].value,\r\n                                    temp: tokensValue[idx].temp + source[0]\r\n                                }\r\n                                if (rule.dfa[states[idx]].exit) {\r\n                                    tokensValue[idx] = {\r\n                                        value: tokensValue[idx].value + tokensValue[idx].temp,\r\n                                        temp: \"\"\r\n                                    }\r\n                                }\r\n                                let link = rule.dfa[states[idx]]\r\n                                    .links\r\n                                    .find(link => link\r\n                                        .action\r\n                                        .test(source[0]))\r\n                                if (link !== undefined) {\r\n\r\n                                    return link.next\r\n                                } else return -1\r\n                            } else return -1\r\n                        })\r\n                }\r\n                break\r\n            }\r\n            case 0: {\r\n                if (source.length !== 0) {\r\n\r\n                }\r\n                break\r\n            }\r\n            case 1: {\r\n                break\r\n            }\r\n        }\r\n        return generated\r\n    }\r\n    let getToken = () => ({ ...token })\r\n    let dropToken = () => {\r\n        switch (generated) {\r\n            case 0: {\r\n                generated = 0\r\n                break\r\n            }\r\n            case 1: {\r\n                generated = 0\r\n                break\r\n            }\r\n        }\r\n        return generated\r\n    }\r\n\r\n    return { reset, addCode, genToken, getToken, dropToken }\r\n}\r\n","export { char, chars, and, or, kleene } from \"./nfa\"\r\nexport { rule, Driver } from './driver';"]}