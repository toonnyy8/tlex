{"version":3,"sources":["nfa.ts","internal/arr.ts","internal/dfa.ts","driver.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"..\\src","sourcesContent":["import { typeNFA } from './type'\r\n\r\nexport const char = (elem: RegExp): typeNFA => [{ action: elem.source, offsets: [1] }, { action: \"\", offsets: <number[]>[] }]\r\nexport const chars = (...elems: RegExp[]): Array<typeNFA> => {\r\n    return elems\r\n        .map(elem => char(elem))\r\n}\r\n\r\nexport const and = (...nfas: Array<typeNFA>): typeNFA => {\r\n    if (nfas.length > 1) return [\r\n        ...nfas[0].slice(0, -1), { ...nfas[0].slice(-1)[0], offsets: [1] },\r\n        ...and(...nfas.slice(1))\r\n    ]\r\n    else return [...nfas[0]]\r\n}\r\n\r\nexport const or = (...nfas: Array<typeNFA>): typeNFA => {\r\n    if (nfas.length > 1) {\r\n        let _or = or(...nfas.slice(1))\r\n        return <typeNFA>[\r\n            { action: null, offsets: [1, nfas[0].length + 1] },\r\n            ...nfas[0].slice(0, -1), { ...nfas[0].slice(-1)[0], offsets: [_or.length + 1] },\r\n            ..._or.slice(0, -1), { ..._or.slice(-1)[0], offsets: [1] },\r\n            { action: null, offsets: [] }\r\n        ]\r\n    } else return [...nfas[0].slice(0, -1), { ...nfas[0].slice(-1)[0], offsets: [] },]\r\n}\r\n\r\nexport const kleene = (nfa: typeNFA): typeNFA => {\r\n    return <typeNFA>[\r\n        { action: null, offsets: [1, nfa.length + 1] },\r\n        ...nfa.slice(0, -1), { ...nfa.slice(-1)[0], offsets: [-nfa.length + 1, 1] },\r\n        { action: null, offsets: [] }\r\n    ]\r\n}","export let arrEq = <T>(as: Array<T>, bs: Array<T>, eq: (a: T, b: T) => boolean) => {\r\n    if (as.length !== bs.length) return false\r\n    return as.find((a, idx) => !eq(a, bs[idx])) === undefined\r\n}\r\nexport let arrAdd = <T>(as: Array<T>, b: T, eq: (a: T, b: T) => boolean) => {\r\n    if (as.find((a) => eq(a, b)) === undefined) return [...as, b]\r\n    else return [...as]\r\n}\r\nexport let arrMerge = <T>(as: Array<T>, bs: Array<T>, eq: (a: T, b: T) => boolean) => {\r\n    return bs.reduce((prevs, b) => arrAdd(prevs, b, eq), as)\r\n}","import { arrAdd, arrEq, arrMerge } from \"./arr\"\r\nimport { typeInterClosureLink, typeInterClosure, typeClosure } from \"./type\"\r\nimport { typeNFA, typeDFA } from \"../type\"\r\n\r\nconst InterClosure = (nfa: typeNFA, state = 0): typeInterClosure => {\r\n    const _InterClosure = (nfa: typeNFA, state = 0): typeInterClosure => {\r\n        if (nfa[state].action === \"\") {\r\n            return nfa[state]\r\n                .offsets\r\n                .map(offset => _InterClosure(nfa, state + offset))\r\n                .reduce((last, cl) =>\r\n                    ({\r\n                        elems: [...last.elems, ...cl.elems],\r\n                        links: [...last.links, ...cl.links]\r\n                    }),\r\n                    <typeInterClosure>{ elems: [state], links: [] }\r\n                )\r\n        } else {\r\n            return <typeInterClosure>{\r\n                elems: [state],\r\n                links: [{ action: nfa[state].action, toElems: [state + nfa[state].offsets[0]] }]\r\n            }\r\n        }\r\n    }\r\n    let icl = _InterClosure(nfa, state)\r\n    icl = {\r\n        elems: [...icl.elems]\r\n            .sort((a, b) => a - b),\r\n        links: mergeILinks(icl.links),\r\n    }\r\n\r\n    return icl\r\n}\r\n\r\nconst mergeILinks = (ilinks: Array<typeInterClosureLink>) => {\r\n    return [...ilinks]\r\n        .sort((a, b) => a.action > b.action ? 1 : a.action === b.action ? 0 : -1)\r\n        .reduce((prevs, curr) => {\r\n            if (prevs.length != 0) {\r\n                let prev = prevs[prevs.length - 1]\r\n                if (prev.action === curr.action) return [\r\n                    ...prevs.slice(0, -1),\r\n                    { ...prev, toElems: arrMerge(prev.toElems, curr.toElems, (a, b) => a === b) }\r\n                ]\r\n                else return [...prevs, curr]\r\n            }\r\n            else return [curr]\r\n        }, <Array<typeInterClosureLink>>[])\r\n}\r\nconst mergeIclosures = (iclosures: typeInterClosure[]): typeInterClosure => {\r\n    return iclosures\r\n        .reduce((prev, curr) => {\r\n            return {\r\n                elems: arrMerge(prev.elems, curr.elems, (a, b) => a === b).sort((a, b) => a - b),\r\n                links: mergeILinks(\r\n                    arrMerge(\r\n                        prev.links,\r\n                        curr.links,\r\n                        (a, b) => a.action === b.action && arrEq(a.toElems, b.toElems, (a, b) => a === b),\r\n                    )\r\n                )\r\n            }\r\n        }, <typeInterClosure>{ elems: [], links: [] })\r\n}\r\nconst unfold = (nfa: typeNFA): typeClosure[] => {\r\n    let solved: typeClosure[] = []\r\n    let unsolved: typeInterClosure[] = [InterClosure(nfa)]\r\n\r\n    while (unsolved.length !== 0) {\r\n        let { all, now } = unsolved[0]\r\n            .links\r\n            .reduce(({ all, now }, link) => {\r\n                let icls = link.toElems.map(toElem => InterClosure(nfa, toElem))\r\n                let icl = mergeIclosures(icls)\r\n                let idx = all.findIndex((_cl) => arrEq(icl.elems, _cl.elems, (a, b) => a === b))\r\n                if (idx === -1) {\r\n                    now = { ...now, links: [...now.links, { action: link.action, toClosure: all.length }] }\r\n                    return { all: [...all, icl], now }\r\n                }\r\n                else {\r\n                    now = { ...now, links: [...now.links, { action: link.action, toClosure: idx }] }\r\n                    return { all, now }\r\n                }\r\n            }, { all: [...solved, ...unsolved], now: <typeClosure>{ elems: unsolved[0].elems, links: [] } })\r\n        unsolved = <Array<typeInterClosure>>all.slice(solved.length + 1)\r\n        solved = [...solved, now]\r\n    }\r\n\r\n    return solved\r\n}\r\n\r\nexport const toDFA = (nfa: typeNFA): typeDFA => {\r\n    let cls = unfold(nfa)\r\n    return <typeDFA>cls.map(cl => {\r\n        if (cl.elems[cl.elems.length - 1] === nfa.length - 1) {\r\n            return { exit: true, links: cl.links.map(link => ({ action: link.action, next: link.toClosure })) }\r\n        } else {\r\n            return { exit: false, links: cl.links.map(link => ({ action: link.action, next: link.toClosure })) }\r\n        }\r\n    })\r\n}","import { typeTokenValue } from \"./internal/type\"\r\nimport { typeNFA, typeRule, typeToken } from \"./type\"\r\nimport { toDFA } from \"./internal/dfa\"\r\n\r\nexport const rule = (token: string, exp: typeNFA): typeRule => ({\r\n    token: token,\r\n    dfa: toDFA(exp),\r\n})\r\n\r\nexport const Driver = (...rules: typeRule[]): {\r\n    reset: () => void,\r\n    addCode: (code: string) => string,\r\n    genToken: () => 0 | 1 | -1,\r\n    getToken: () => typeToken,\r\n    dropToken: () => 0 | -1,\r\n} => {\r\n    let states: Array<number> = new Array(rules.length).fill(0)\r\n    let tokensValue: Array<typeTokenValue> = new Array(rules.length).fill({ value: \"\", temp: \"\" })\r\n\r\n    let _rules = rules\r\n        .map(rule => ({\r\n            ...rules,\r\n            dfa: rule\r\n                .dfa\r\n                .map(_dfa => ({\r\n                    ..._dfa,\r\n                    links: _dfa\r\n                        .links\r\n                        .map(link => ({\r\n                            ...link,\r\n                            action: new RegExp(link.action)\r\n                        }))\r\n                }))\r\n        }))\r\n    let source: string\r\n    let line: number = 0\r\n    let col: number = 0\r\n    let token: typeToken = { token: \"\", symbol: \"\", line, col }\r\n    // generated = -1 : semifinished\r\n    // generated = 0  : not generated\r\n    // generated = 1  : finished\r\n    let generated: -1 | 0 | 1\r\n\r\n    let reset = () => {\r\n        source = \"\"\r\n        line = 0\r\n        col = 0\r\n    }\r\n    let addCode = (code: string) => {\r\n        source += code\r\n        return source\r\n    }\r\n\r\n    let genToken = () => {\r\n        if (source[0] === \"\\n\") {\r\n            line += 1\r\n            col = 0\r\n        }\r\n        switch (generated) {\r\n            case -1: {\r\n                if (source.length !== 0) {\r\n                    states = _rules\r\n                        .map((rule, idx) => {\r\n                            if (states[idx] !== -1) {\r\n                                tokensValue[idx] = {\r\n                                    symbol: tokensValue[idx].symbol,\r\n                                    temp: tokensValue[idx].temp + source[0]\r\n                                }\r\n                                if (rule.dfa[states[idx]].exit) {\r\n                                    tokensValue[idx] = {\r\n                                        symbol: tokensValue[idx].symbol + tokensValue[idx].temp,\r\n                                        temp: \"\"\r\n                                    }\r\n                                }\r\n                                let link = rule.dfa[states[idx]]\r\n                                    .links\r\n                                    .find(link => link\r\n                                        .action\r\n                                        .test(source[0]))\r\n                                if (link !== undefined) {\r\n\r\n                                    return link.next\r\n                                } else return -1\r\n                            } else return -1\r\n                        })\r\n                }\r\n                break\r\n            }\r\n            case 0: {\r\n                if (source.length !== 0) {\r\n\r\n                }\r\n                break\r\n            }\r\n            case 1: {\r\n                break\r\n            }\r\n        }\r\n        return generated\r\n    }\r\n    let getToken = () => ({ ...token })\r\n    let dropToken = () => {\r\n        switch (generated) {\r\n            case 0: {\r\n                generated = 0\r\n                break\r\n            }\r\n            case 1: {\r\n                generated = 0\r\n                break\r\n            }\r\n        }\r\n        return generated\r\n    }\r\n\r\n    return { reset, addCode, genToken, getToken, dropToken }\r\n}\r\n","export { char, chars, and, or, kleene } from \"./nfa\"\r\nexport { rule, Driver } from './driver';"]}